<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ 模板</title>
    <link href="/2025/06/18/C++%20%E6%A8%A1%E6%9D%BF/"/>
    <url>/2025/06/18/C++%20%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>模板是程序员编写的一种与类型无关的代码结构（蓝图），用于生成不同类型的对应具体实现，并且只有在使用时才进行实例化，生成该类型的具体实现。</p><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2 基本语法"></a>2 基本语法</h2><h3 id="2-1-函数模板"><a href="#2-1-函数模板" class="headerlink" title="2.1 函数模板"></a>2.1 函数模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span></span>&#123; <span class="hljs-keyword">return</span> a + b;&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-类模板"><a href="#2-2-类模板" class="headerlink" title="2.2 类模板"></a>2.2 类模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">T <span class="hljs-title">getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_x; &#125;<br>  T m_x; T m_y;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3 基本使用"></a>3 基本使用</h2><h3 id="3-1-函数模板"><a href="#3-1-函数模板" class="headerlink" title="3.1 函数模板"></a>3.1 函数模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// 1 定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>&#123; <span class="hljs-keyword">return</span> a &gt; b ? a : b;&#125;<br><span class="hljs-comment">/// 2 不显示指导类型使用</span><br><span class="hljs-keyword">auto</span>    m = <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">/// 3 显示指定类型使用</span><br><span class="hljs-type">double</span> m = <span class="hljs-built_in">max</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">2.4</span>, <span class="hljs-number">1.5</span>);<br><span class="hljs-comment">/// 4 默认模板参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Comparator = std::less&lt;T&gt;&gt;<br><span class="hljs-type">bool</span> <span class="hljs-built_in">compare</span>(T a, T b)&#123; Comparator c; <span class="hljs-keyword">return</span> <span class="hljs-built_in">c</span>(a, b); &#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-类模板"><a href="#3-2-类模板" class="headerlink" title="3.2 类模板"></a>3.2 类模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// 1 声明和定义（一般放在同1个头文件中）</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>  T m_x; T m_y;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Point</span>(T x, T y) : <span class="hljs-built_in">m_x</span>(x), <span class="hljs-built_in">m_y</span>(y)&#123; &#125;<br>  <span class="hljs-function">T <span class="hljs-title">getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_x;&#125;<br>  <span class="hljs-function">T <span class="hljs-title">getY</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T Point&lt;T&gt;::<span class="hljs-built_in">getY</span>() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> m_y; &#125;<br><span class="hljs-comment">/// 2 必须显示指定类型使用</span><br><span class="hljs-function">Point&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">pos</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span></span>;<br><span class="hljs-comment">/// 3 默认模板参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">double</span>&gt;<br><span class="hljs-keyword">class</span> Point&#123;...&#125;<br><span class="hljs-comment">/// 4 继承</span><br><span class="hljs-keyword">class</span> Point3D : <span class="hljs-keyword">public</span> Point&lt;<span class="hljs-type">int</span>&gt;&#123;...&#125;<span class="hljs-comment">/// 普通类继承自模板类</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> Point3D : <span class="hljs-keyword">public</span> Point&lt;T&gt;&#123;...&#125;  <span class="hljs-comment">/// 模板类继承自模板类</span><br><span class="hljs-comment">/// 5 静态成员：每个静态成员对于每个T各自拥有一份(Point&lt;int&gt;::getSum和Point&lt;double&gt;::getSum不一样)</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> Point&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">static</span> T <span class="hljs-built_in">getSum</span>() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> m_sum; &#125;<br>  <span class="hljs-type">static</span> T m_sum;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T Point&lt;T&gt;::m_sum = <span class="hljs-built_in">T</span>();<span class="hljs-comment">/// 通用初始化</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T Point&lt;T&gt;::m_sum = <span class="hljs-number">0</span>;  <span class="hljs-comment">/// 错误，不是所有类型都接受0为初始值</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">int</span> Point&lt;<span class="hljs-type">int</span>&gt;::m_sum = <span class="hljs-number">0</span>;<span class="hljs-comment">/// 正确，对int进行特化初始化</span><br></code></pre></td></tr></table></figure><h2 id="4-进阶使用"><a href="#4-进阶使用" class="headerlink" title="4 进阶使用"></a>4 进阶使用</h2><h3 id="4-1-特化"><a href="#4-1-特化" class="headerlink" title="4.1 特化"></a>4.1 特化</h3><p>当通用模板对某个类型不适应，或者有比通用模板更优实现时，可以针对该类型进行定制实现，如标准库中的<code>std::vector&lt;bool&gt;</code>特化。</p><h4 id="4-1-1-函数模板特化"><a href="#4-1-1-函数模板特化" class="headerlink" title="4.1.1 函数模板特化"></a>4.1.1 函数模板特化</h4><ul><li>函数模板可以和普通函数重载，编译器优先选择非模版版本（更“特化”）；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;non template: x=&quot;</span>&lt;&lt;x&lt;&lt;endl; &#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(T x)</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;template: x=&quot;</span>&lt;&lt;x&lt;&lt;endl; &#125;<br><span class="hljs-built_in">display</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">/// 输出non template: x=10 </span><br></code></pre></td></tr></table></figure><ul><li><strong>全特化</strong>（函数模板没有偏特化）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>&#123;<span class="hljs-keyword">return</span> a &gt; b ? a : b; &#125;<br><span class="hljs-comment">/// 对std::string进行全特化（可以重载运算符&gt;来适配上面的通用模板函数达到一样的效果</span><br><span class="hljs-keyword">using</span> str = std::string;<br><span class="hljs-keyword">template</span>&lt;&gt; str <span class="hljs-built_in">max</span>&lt;std::string&gt;(str a, str b)&#123; <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt; b.<span class="hljs-built_in">size</span>() ? a : b; &#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-2-类模板特化"><a href="#4-1-2-类模板特化" class="headerlink" title="4.1.2 类模板特化"></a>4.1.2 类模板特化</h4><ol><li><strong>偏特化</strong></li></ol><ul><li>指针、引用、数组、const常量等偏特化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;...&#125;<br><span class="hljs-comment">/// 指针偏特化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T*&gt;&#123;...&#125;<br><span class="hljs-comment">/// 常量指针（组合偏特化）</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">const</span> T*&gt;&#123;...&#125;<br><span class="hljs-comment">/// 右值引用偏特化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T&amp;&amp;&gt;&#123;...&#125;<br><span class="hljs-comment">/// 数组偏特特化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T[N]&gt;&#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li>类型参数偏特化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&#123;...&#125;<br><span class="hljs-comment">/// 只对第二个模板参数特化的偏特化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;<span class="hljs-type">bool</span>&gt;&#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li>非类型参数偏特化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&#123;...&#125;<br><span class="hljs-comment">/// 非类型参数0的偏特化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&lt;T, <span class="hljs-number">0</span>&gt;&#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li>模板参数为某个模板类型时的偏特化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;...&#125;<br><span class="hljs-comment">/// 模板参数为std::vector&lt;T&gt;类型时的偏特化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&lt;std::vector&lt;T&gt;&gt;&#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li>使用部分类型模板参数匹配（类型萃取）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; <br><span class="hljs-comment">/// 主模板留空或static_asser</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PairTraits</span>;<br><span class="hljs-comment">/// 偏特化pair,提取第一个模板参数类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PairTraits</span>&lt;std::pair&lt;T1, T2&gt;&gt;&#123; <span class="hljs-keyword">using</span> firstType = T1; &#125;<br>PairTraits&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;&gt;::firstType i = <span class="hljs-number">42</span>;  <span class="hljs-comment">/// int </span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>全特化</strong></li></ol><ul><li>类型参数全特化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// 单个类型参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&#123;...&#125;<br><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;<span class="hljs-type">bool</span>&gt;&#123;...&#125;<br><span class="hljs-comment">/// 多个类型参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;...&#125;<br><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;&#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li>带非类型参数全特化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&#123;...&#125;<br><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-type">char</span>, <span class="hljs-number">0</span>&gt;&#123;...&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-显示实例化"><a href="#4-2-显示实例化" class="headerlink" title="4.2 显示实例化"></a>4.2 显示实例化</h3><p>在c++中模板相当于“蓝图”，当它们被调用时才会实例化为具体类型版本的函数，这意味着一个函数模板在不同编译单元（通常对应于源文件）会进行多次编译，造成不必要的开销和可能出现重定义错误，显示实例化提前实例化，避免在多个编译单元多次调用时的多次实例化。</p><h4 id="4-2-1-函数模板显示实例化"><a href="#4-2-1-函数模板显示实例化" class="headerlink" title="4.2.1 函数模板显示实例化"></a>4.2.1 函数模板显示实例化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &gt; b ? a : b; &#125; <span class="hljs-comment">/// max函数模板完整通用定义</span><br><span class="hljs-keyword">template</span> <span class="hljs-type">int</span> <span class="hljs-built_in">max</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>); <span class="hljs-comment">/// 在.cpp文件中显示实例化T=int版本</span><br></code></pre></td></tr></table></figure><h4 id="4-2-2-类模板显示实例化"><a href="#4-2-2-类模板显示实例化" class="headerlink" title="4.2.2 类模板显示实例化"></a>4.2.2 类模板显示实例化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;...&#125;<span class="hljs-comment">/// MyClass类模板完整通用定义</span><br><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">int</span>&gt;;<span class="hljs-comment">/// 在.cpp文件中显示实例T=int版本</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：显示实例化前一定要存在模板完整的通用定义，并且显示实例化推荐编写在<code>.cpp</code>文件中，编写在<code>.h</code>文件中会导致出现在每个包含该<code>.h</code>的<code>.cpp</code>文件中。 </p><h3 id="4-3-非类型参数"><a href="#4-3-非类型参数" class="headerlink" title="4.3 非类型参数"></a>4.3 非类型参数</h3><p>非类型模板参数是指在模板参数列表中使用一个值（如整数、指针、引用等）作为参数，而不是一个类型，<strong>非类型参数必须是编译期常量值</strong>(<code>constexpr</code>属性)，这就是它和普通参数传递的区别，使用非类型参数可以保证编译期就计算和实例化。</p><h4 id="4-3-1-函数模板非类型参数"><a href="#4-3-1-函数模板非类型参数" class="headerlink" title="4.3.1 函数模板非类型参数"></a>4.3.1 函数模板非类型参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(T (&amp;arr)[N])</span></span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)cout&lt;&lt;arr[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>; &#125; <br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<span class="hljs-type">int</span> arr[n] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">/// n变量编译期确定值</span><br><span class="hljs-built_in">printArray</span>&lt;n&gt;(arr);<span class="hljs-comment">/// 调用</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(N == <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">return</span> 1</span>; <span class="hljs-comment">/// 当N == 0时,使用if constexpr确保不实例化factorial&lt;-1&gt;()模板,</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> N * <span class="hljs-built_in">factorial</span>&lt;N - <span class="hljs-number">1</span>&gt;();  <span class="hljs-comment">/// 避免无限递归和编译错误, 函数虽然不是constexpr函数，但是</span><br>&#125; <span class="hljs-comment">/// if constexpr 仍然在编译期处理逻辑，也就是返回编译期常量结果</span><br><span class="hljs-type">int</span> i = <span class="hljs-built_in">factorial</span>&lt;<span class="hljs-number">5</span>&gt;(); <span class="hljs-comment">/// 调用，注意常量结果可以用普通变量接收</span><br></code></pre></td></tr></table></figure><h4 id="4-3-2-类模板非类型参数"><a href="#4-3-2-类模板非类型参数" class="headerlink" title="4.3.2 类模板非类型参数"></a>4.3.2 类模板非类型参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> N&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br>  T m_data[N];<br><span class="hljs-keyword">public</span>:<br>  T&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> index) &#123;<span class="hljs-keyword">return</span> m_data[index];&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-SFINAE的使用"><a href="#4-4-SFINAE的使用" class="headerlink" title="4.4 SFINAE的使用"></a>4.4 SFINAE的使用</h3><p>匹配失败并非错误（Substitution Failure Is Not An Error）作用于模板参数替换阶段，非法替换不会导致编译失败，而是忽略该版本， 在范型编程中常用来进行条件编译，条件性启用或禁用类模板（也可以只针对某个成员函数）和函数模板。</p><h4 id="4-4-1-函数模板SFINAE的使用"><a href="#4-4-1-函数模板SFINAE的使用" class="headerlink" title="4.4.1 函数模板SFINAE的使用"></a>4.4.1 函数模板SFINAE的使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::<span class="hljs-function">type</span><br><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span></span>&#123; <span class="hljs-keyword">return</span> a + b; &#125; <br><span class="hljs-comment">/// 1 如果T为int、long等整形就编译实例化该类型版本函数，否则不报错忽略该版本</span><br><span class="hljs-comment">/// 2 typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type还有以下写法</span><br><span class="hljs-comment">///    typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type没有第二个T，这种写法第二个T</span><br><span class="hljs-comment">/// 使用默认值void，也就是不关心add函数返回值类型使用void。 </span><br></code></pre></td></tr></table></figure><h4 id="4-4-2-类模板SFINAE的使用"><a href="#4-4-2-类模板SFINAE的使用" class="headerlink" title="4.4.2 类模板SFINAE的使用"></a>4.4.2 类模板SFINAE的使用</h4><ul><li>针对整个类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/// 类模板完整通用定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt; <span class="hljs-keyword">class</span> MyClass&#123;<span class="hljs-type">void</span> <span class="hljs-built_in">print</span>() &#123;cout&lt;&lt;<span class="hljs-string">&quot;normal&quot;</span>&lt;&lt;endl;&#125;  <br><span class="hljs-comment">/// 偏特化 + SFINAE启用（比正常偏特化范围更广，下面实例比配int、bool、char、long等所有“整形”）</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_intergral&lt;T&gt;::value&gt;::type&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;intergral&quot;</span>&lt;&lt;endl;&#125;&#125;<br><span class="hljs-comment">/// 1. 通用定义中模板参数列表完整写法为template &lt;typename T, typename U = void&gt;, 由于U只用做</span><br><span class="hljs-comment">///     SFINAE控制，不在类内使用所以通常忽略名字；</span><br><span class="hljs-comment">/// 2. 偏特化+SFINAE启用版本中，当T为整形，则std::is_intergral&lt;T&gt;::value = true, </span><br><span class="hljs-comment">///     而std::enable_if&lt;true&gt;::type = void,所以生成针对整形的特化版本：</span><br><span class="hljs-comment">///      class MyClass&lt;T, void&gt;&#123; void print() &#123;cout&lt;&lt;&quot;intergral&quot;&lt;&lt;endl;&#125;&#125;</span><br><span class="hljs-comment">///     如果T不是整形，std::enable_if&lt;false&gt;::type 不存在，替换失败 → 触发 SFINAE → 忽略这个特化，继</span><br><span class="hljs-comment">///     续匹配通用模板（类似兜底实现）。    </span><br></code></pre></td></tr></table></figure><ul><li>针对成员函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass</span>&#123;<br>   <span class="hljs-comment">/// 只有当T是整形时，这个函数才存在</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U = T&gt;<br>   <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_intergral&lt;U&gt;::value, T&gt;::type<br>      <span class="hljs-built_in">func</span>()&#123;...&#125;<br>&#125;<br><span class="hljs-comment">/// 1.template &lt;typename U = T&gt;不能省略，当把std::enable_if写成成员函数返回值时，直接使用外层的T时</span><br><span class="hljs-comment">/// 会导致SFINAE不起作用，std::enable_if&lt;...&gt;放在func函数的返回值部分。</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：类模板有自己的模板参数列表才算类模板的成员函数模板，不然只能算是普通成员函数。</p><ul><li>使用继承做类型选择（类型萃取 + SFINAE）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">IsIntergral</span> : <span class="hljs-keyword">public</span> std::enable_if&lt;std::is_intergral&lt;T&gt;::value&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;std::cout&lt;&lt;<span class="hljs-string">&quot;Intergral Class&quot;</span>&lt;&lt;endl; &#125;<br>&#125;<br><span class="hljs-comment">/// 只有当T为整形才继承成功</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIntergral</span> : <span class="hljs-keyword">public</span> IsIntergral&lt;T&gt;&#123;...&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-函数模板特有进阶使用"><a href="#4-5-函数模板特有进阶使用" class="headerlink" title="4.5 函数模板特有进阶使用"></a>4.5 函数模板特有进阶使用</h3><ul><li>完美转发（详情请看<strong>完美转发</strong>篇）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; arg)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(process(std::forward&lt;T&gt;(arg)))</span> </span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">process</span>(std::forward&lt;T&gt;(arg)); &#125; <span class="hljs-comment">/// C++14以上可省略后置返回值类型</span><br></code></pre></td></tr></table></figure><ul><li>可变参数（同时用到<strong>完美转发</strong>）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">create</span><span class="hljs-params">(Args&amp;&amp;... args)</span> -&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(T(std::forward&lt;Args&gt;(args)...))</span>      </span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>(std::forward&lt;Args&gt;(args)...); &#125;<br></code></pre></td></tr></table></figure><h2 id="5-注意实现"><a href="#5-注意实现" class="headerlink" title="5 注意实现"></a>5 注意实现</h2><h3 id="5-1-共同注意事项"><a href="#5-1-共同注意事项" class="headerlink" title="5.1 共同注意事项"></a>5.1 共同注意事项</h3><ul><li>模板不能自动进行类型转换;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>&#123; <span class="hljs-keyword">return</span> a &gt; b ? a : b;&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>  T m_data;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">MyClass</span>(T a) : <span class="hljs-built_in">m_data</span>(a)&#123;&#125;<br>&#125;<br><span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>);<span class="hljs-comment">/// 错误，int和double无法推导为同一T</span><br><span class="hljs-built_in">max</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>); <span class="hljs-comment">/// 正确，显示指导为double</span><br><span class="hljs-function">MyClass <span class="hljs-title">mc</span><span class="hljs-params">(<span class="hljs-number">1.50</span>)</span></span>;<span class="hljs-comment">/// 错误，类模板必须显示指定类型，不能自动推导</span><br></code></pre></td></tr></table></figure><ul><li>模板声明和定义通常放于<code>.h</code>头文件中;</li><li>实例化发生在使用时；</li><li>模板参数有时不能正确推导，可能需要显式指定</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T a)</span></span>&#123;...&#125;<br><span class="hljs-built_in">func</span>(<span class="hljs-literal">nullptr</span>);      <span class="hljs-comment">/// 错误，nullpter不能推导类型T</span><br><span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">/// 正确，显示指定类型</span><br></code></pre></td></tr></table></figure><ul><li>模板和重载&#x2F;特化的冲突， 需要注意优先级和歧义，非函数模板优先于函数模板， 特化优于通用模板，可以用 <code>enable_if</code> 控制参与重载的条件（SFINAE 技巧）；</li><li>由于模板实例化的延迟性质，错误可能出现在离使用点很远的地方，调试模板时要有耐心；</li></ul><h3 id="5-2-类模板特有注意事项"><a href="#5-2-类模板特有注意事项" class="headerlink" title="5.2 类模板特有注意事项"></a>5.2 类模板特有注意事项</h3><ul><li>如果类模板中有友元函数，声明方式比较特殊。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/// 方式一， 普通函数和类做友元函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>  T m_data;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span>  <span class="hljs-title">show</span><span class="hljs-params">(MyClass&lt;T&gt;&amp; obj)</span></span>;     <br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFriend</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(MyClass&lt;T&gt;&amp; obj)</span></span>&#123; cout&lt;&lt;obj.m_data&lt;&lt;endl;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFriend</span>&#123; <br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(MyClass&lt;T&gt;&amp; obj)</span></span>&#123; cout&lt;&lt;obj.m_data&lt;&lt;endl;&#125; <br>&#125;<br><br><span class="hljs-comment">/// 方法二， 函数模板和类模板做友元函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>  T m_data;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span>  show&lt;&gt;(MyClass&lt;T&gt;&amp; obj);  <br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFriend</span>&lt;T&gt;; <span class="hljs-comment">/// 当友元类模板和函数模板的模板参数和当前类模板的参数同名时，也可以省</span><br>    <span class="hljs-comment">/// 略模板参数列表，函数模板只需添加&lt;&gt;类模板添加&lt;T&gt;表明是模板即可。 </span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt; <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span>  <span class="hljs-title">print</span><span class="hljs-params">(MyClass&lt;T&gt;&amp; obj, T1 a)</span></span>;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt; <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">MyFriend_01</span>;    <br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(yClass&lt;T&gt;&amp; obj)</span></span>&#123; cout&lt;&lt;obj.m_data&lt;&lt;endl;&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(yClass&lt;T&gt;&amp; obj, T1 a)</span></span>&#123; cout&lt;&lt;obj.m_data&lt;&lt;a&lt;&lt;endl;&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFriend</span>&#123; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(MyClass&lt;T&gt;&amp; obj)</span></span>&#123; cout&lt;&lt;obj.m_data&lt;&lt;endl;&#125; &#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFriend_01</span>&#123; <br>  T1 m_data;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(MyClass&lt;T&gt;&amp; obj)</span></span>&#123; cout&lt;&lt;obj.m_data&lt;&lt;m_data&lt;&lt;endl;&#125; <br>&#125;<br><span class="hljs-comment">/// 1. 方式一和方式二不同点在于方式一在对每个类型实例化时都要重新把该类型对应的show&lt;T&gt;函数声明为</span><br><span class="hljs-comment">///     类模板的友元函数，而方式二是告诉编译器把所有类模板实例和show&lt;T&gt;函数绑定为友元关系，对于开</span><br><span class="hljs-comment">///     发人员来说在使用上没有区别，只是在编译器层面有区别，推荐使用方式二</span><br><span class="hljs-comment">/// 2. 两种方式的友元函数定义是一摸一样的。</span><br><span class="hljs-comment">/// 3. 实例代码缺少前向声明</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言与框架</category>
      
      <category>C++</category>
      
      <category>C++模板</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11 auto/decltype/返回值类型后置</title>
    <link href="/2025/06/18/C++11%2004%20auto%20l%20decltype%20l%20%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE/"/>
    <url>/2025/06/18/C++11%2004%20auto%20l%20decltype%20l%20%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="一、auto"><a href="#一、auto" class="headerlink" title="一、auto"></a>一、auto</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> name = value;<br></code></pre></td></tr></table></figure><h3 id="1-推导规则"><a href="#1-推导规则" class="headerlink" title="1 推导规则"></a>1 推导规则</h3><ul><li>auto根据赋值号（&#x3D;）右边值的类型推导类型，<code>因此声明时必须初始化</code>；</li><li>auto会退化表达式的引用性（<code>100%</code>）和顶层<code>CV</code>限定符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>   k = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> i = <span class="hljs-number">10</span>;  <span class="hljs-keyword">auto</span> j = i;<span class="hljs-comment">// j推导为int,忽略顶层const</span><br><span class="hljs-type">int</span>&amp;  n = k;   <span class="hljs-keyword">auto</span> m = k;<span class="hljs-comment">// m推导为int,忽略引用属性</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：<code>auto只是一个占位符，编译期间就会被替换为正真的类型</code></p><h3 id="2-单独使用以及结合使用"><a href="#2-单独使用以及结合使用" class="headerlink" title="2 单独使用以及结合使用"></a>2 单独使用以及结合使用</h3><ul><li>单独使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> j = i;<br></code></pre></td></tr></table></figure><ul><li>结合使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span>* p = &amp;i;<span class="hljs-comment">// p类型为int*, 因此auto为int</span><br><span class="hljs-keyword">auto</span>&amp; r = i;<span class="hljs-comment">// r类型为int&amp;, 因此auto为int</span><br></code></pre></td></tr></table></figure><h3 id="3-经典使用场景"><a href="#3-经典使用场景" class="headerlink" title="3 经典使用场景"></a>3 经典使用场景</h3><ul><li>简化复杂书写类型的声明（如：STL容器迭代器）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; ids; <br><span class="hljs-keyword">auto</span> iter = ids.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> sp   = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><ul><li>lamdab表达式</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> fncAdd = [=](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123;<span class="hljs-keyword">return</span> a + b;&#125;<br></code></pre></td></tr></table></figure><ul><li>返回for循环</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; ids; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; elem: ids)&#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>泛型编程返回值类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t+u)</span></span>&#123; <span class="hljs-keyword">return</span> t+u;&#125;<br></code></pre></td></tr></table></figure><h3 id="4-不能使用场景"><a href="#4-不能使用场景" class="headerlink" title="4 不能使用场景"></a>4 不能使用场景</h3><ul><li>不能在函数参数中使用</li><li>不能用于声明类的非静态成员变量</li><li>不能用于定义数组</li><li>不能用于模板参数（如：<code>vector&lt;auto&gt; ids;</code>）</li></ul><p>&#x3D;&#x3D;提醒&#x3D;&#x3D;：没有必要使用auto时，尽量不用使用，auto的过多使用，会增加代码阅读难度。</p><h2 id="二、decltype"><a href="#二、decltype" class="headerlink" title="二、decltype"></a>二、decltype</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">decltype</span>(exp) name;<br></code></pre></td></tr></table></figure><h3 id="1-推导规则-1"><a href="#1-推导规则-1" class="headerlink" title="1 推导规则"></a>1 推导规则</h3><ul><li>如果<code>exp</code>是单独的变量、类成员访问表达式（<code>obj.member 或 ptr-&gt;member</code>）或者是一个没有<code>()</code>包围的表达式，那么<code>decltype(exp)</code>类型和<code>exp</code>类型一致；</li><li>如果<code>exp</code>是一个函数调用，那么<code>decltype(exp)</code>类型和函数返回值一致（但函数不会执行）；</li><li>如果<code>exp</code>是左值，或者<code>exp</code>是<code>()</code>包围的表达式，那么<code>decltype(exp)</code>类型是T&amp;;</li><li>如果<code>exp</code>是一个 临时对象（右值），则 <code>decltype(exp)</code>类型为T，不带引用；</li></ul><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：<code>1 decltype也是用于编译期间用于进行类型推导的</code></p><p>​     <code>2  decltype会保留表达式的引用和CV限定符属性</code></p><h3 id="2-返回值类型后置（尾随返回值类型）"><a href="#2-返回值类型后置（尾随返回值类型）" class="headerlink" title="2 返回值类型后置（尾随返回值类型）"></a>2 返回值类型后置（尾随返回值类型）</h3><p>​使用 <code>-&gt;</code> 后置返回类型，结合 <code>auto</code> 和 <code>decltype</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t+u)</span></span>&#123; <span class="hljs-keyword">return</span> t+u;&#125;<br></code></pre></td></tr></table></figure><p><code>注意：从C++14开始，可以省略返回值类型后置（尾随返回值类型），需要保证多处return返回的类型一样</code></p><h3 id="3-经典使用场景-1"><a href="#3-经典使用场景-1" class="headerlink" title="3 经典使用场景"></a>3 经典使用场景</h3><ul><li>配合<code>auto</code>实现函数返回值类型推导</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t+u)</span></span>&#123; <span class="hljs-keyword">return</span> t+u;&#125;<br></code></pre></td></tr></table></figure><ul><li>配合<code>std::declval</code>构造虚拟对象（不构造真实对象）进行类型推导（常用于模板元编程）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Math</span>&#123;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> a+b;&#125;&#125;<br><span class="hljs-keyword">using</span>  t = <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;Math&gt;().<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><ul><li><code>decltype(auto)</code>用于保留类型的CV限定符和引用属性，比如完美转发中函数的返回值(C++14起 )</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">Func</span><span class="hljs-params">(T&amp;&amp; t)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Func1</span>(std::forward&lt;T&gt;(t));&#125;<br></code></pre></td></tr></table></figure><h2 id="三、疑惑"><a href="#三、疑惑" class="headerlink" title="三、疑惑"></a>三、疑惑</h2><h3 id="1-泛型编程中函数返回值类型为啥不是由auto根据函数返回值类型决定，而是由decltype指定"><a href="#1-泛型编程中函数返回值类型为啥不是由auto根据函数返回值类型决定，而是由decltype指定" class="headerlink" title="1 泛型编程中函数返回值类型为啥不是由auto根据函数返回值类型决定，而是由decltype指定"></a>1 泛型编程中函数返回值类型为啥不是由<code>auto</code>根据函数返回值类型决定，而是由decltype指定</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t+u)</span></span>&#123; <span class="hljs-keyword">return</span> t+u;&#125;<br></code></pre></td></tr></table></figure><p>解答：函数的返回值类型需要在函数签名（编译期间）确定，这时还没有返回值（运行期间），因此当函数的返回值类型为<code>auto</code>时，其类型只能返回值类型后置的<code>decltype(exp)</code>来确定,<code>C++14</code>以上可以省略。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言与框架</category>
      
      <category>C++</category>
      
      <category>C++11</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11 多线程支持</title>
    <link href="/2025/06/18/C++11%2005%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81/"/>
    <url>/2025/06/18/C++11%2005%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一、线程管理：std-thread"><a href="#一、线程管理：std-thread" class="headerlink" title="一、线程管理：std::thread"></a>一、线程管理：<code>std::thread</code></h2><h3 id="1-支持的可调用对象"><a href="#1-支持的可调用对象" class="headerlink" title="1 支持的可调用对象"></a>1 支持的可调用对象</h3><ul><li>函数指针</li><li>lambda匿名函数（本质也是一种函数对象）</li><li>函数对象（仿函数）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(...)</span> </span>&#123; ... &#125;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func;<span class="hljs-comment">// 函数指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">std::thread t2([]()&#123;...&#125;);<span class="hljs-comment">// lambda</span></span></span><br><span class="hljs-params"><span class="hljs-function">std::thread t3(Functor(), arg1, arg2); <span class="hljs-comment">// 函数对象</span></span></span><br></code></pre></td></tr></table></figure><h3 id="2-参数传递和返回值"><a href="#2-参数传递和返回值" class="headerlink" title="2 参数传递和返回值"></a>2 参数传递和返回值</h3><ul><li>参数默认使用值传统，引用传统需显示使用<code>std::ref</code>指出;</li><li><code>std::thread</code>默认没有设计直接获取返回值，但是可以通过引用类型的参数传回或者通过<code>std::promise</code>+<code>std::future</code>获取。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> in = <span class="hljs-number">10</span>, iResult = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>&amp; result)</span> </span>&#123; result = n%<span class="hljs-number">2</span>;&#125;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func, in, std::ref(iResult))</span></span>; <span class="hljs-comment">// in值传递，iResult显示指出引用传递，获取返回结果</span><br><br>std::promise&lt;<span class="hljs-type">int</span>&gt; prom;<span class="hljs-comment">// std::promise+std::future获取返回值</span><br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;prom](<span class="hljs-type">int</span> n)&#123; prom.set_value(n % <span class="hljs-number">2</span>);&#125;, in)</span></span>;<br>iResult = prom.<span class="hljs-built_in">get_future</span>().<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><h3 id="3-join-和detach"><a href="#3-join-和detach" class="headerlink" title="3 join()和detach()"></a>3 join()和detach()</h3><ul><li><code>join()</code>会堵塞主线程，<code>detach()</code>分离主线程和新线程，主线程和新线程（后台）同时执行；</li><li>如果<code>std::thread</code>对象未调用<code>join()/detach()</code>(joinable状态下)就析构，会导致调用<code>std::terminate()</code>,最终导致资源未得到正确释放或者其他未定义行为。</li></ul><p><strong>推荐做法：对<code>std::RAII</code>封装</strong>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuradThread</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GuradThread</span><span class="hljs-params">(std::thread&amp;&amp; t)</span></span>&#123;m_thread = std::<span class="hljs-built_in">move</span>(t);&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">GuradThread</span>()&#123;<span class="hljs-keyword">if</span> (m_thread.<span class="hljs-built_in">joinable</span>())m_thread.<span class="hljs-built_in">join</span>();&#125;<br>    <span class="hljs-built_in">GuradThread</span>(<span class="hljs-type">const</span> GuradThread&amp; ) = <span class="hljs-keyword">delete</span>;<br>    GuradThread&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> GuradThread&amp; ) = <span class="hljs-keyword">delete</span>;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::thread m_thread;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、异步任务和结果获取：std-future-std-asycn"><a href="#二、异步任务和结果获取：std-future-std-asycn" class="headerlink" title="二、异步任务和结果获取：std::future + std::asycn"></a>二、异步任务和结果获取：<code>std::future</code> + <code>std::asycn</code></h2><h3 id="1-std-future"><a href="#1-std-future" class="headerlink" title="1 std::future"></a>1 <code>std::future</code></h3><ul><li>获取异步操作的结果，它像一个等待异步计数结果的占位符；</li><li>与 <code>std::promise</code>、<code>std::packaged_task</code> 或 <code>std::async</code> 结合使用。</li></ul><h3 id="2-std-async"><a href="#2-std-async" class="headerlink" title="2 std::async"></a>2 <code>std::async</code></h3><ul><li>启用异步任务，返回一个获取异步结果的<code>std::future</code>（异步任务不一定已经完成）；</li><li>使用语法：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> future = std::<span class="hljs-built_in">async</span>(policy, func, args...);<br></code></pre></td></tr></table></figure><ul><li><strong><code>policy</code></strong>:启动策略<ul><li><code>std::launch::async</code>：强制新线程异步执行。</li><li><code>std::launch::deferred</code>：延迟执行（调用 <code>.get()</code> 时在当前线程同步运行）。</li><li>默认策略（省略参数）：由系统决定，可能是异步或延迟。</li></ul></li></ul><h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3 使用场景"></a>3 使用场景</h3><ul><li>异步耗时任务（比如<code>GUI</code>成绩数据的后台处理）；</li><li>并行任务；</li><li>延迟计数。</li></ul><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4 注意事项"></a>4 注意事项</h3><ul><li><code>std::future</code>的<code>get()</code>只能调用一次，多次调用导致<code>std::future_error</code> 异常；</li><li>确保<code>std::future</code>生命周期覆盖异步任务执行时间，否则在析构<code>std::future</code>位置会阻塞等待异步任务完成；</li><li>默认策略（<code>std::async(func)</code>）可能延迟执行，导致并发性不可控，<strong>建议显式指定策略</strong>；</li><li><code>std::async</code>的参数<code>args...</code>默认按值传递，如需按引用传递，需使用<code>std::ref</code>显示指出。</li></ul><h2 id="二、数据同步："><a href="#二、数据同步：" class="headerlink" title="二、数据同步："></a>二、数据同步：</h2><h3 id="1-std-atomic"><a href="#1-std-atomic" class="headerlink" title="1 std::atomic"></a>1 <code>std::atomic</code></h3><h4 id="1-1-适用场景："><a href="#1-1-适用场景：" class="headerlink" title="1.1 适用场景："></a>1.1 <strong>适用场景</strong>：</h4><p>​小型简单数据的同步，如全局计数器、标志位、指针管理（链表的头指针等）。</p><h4 id="1-2-最常用内存序组合："><a href="#1-2-最常用内存序组合：" class="headerlink" title="1.2 最常用内存序组合："></a>1.2 <strong>最常用内存序组合</strong>：</h4><table><thead><tr><th align="left">memory_order_relaxed</th><th>只关心原子性，不关心顺序</th></tr></thead><tbody><tr><td align="left"><strong>memory_order_release + memory_order_acquire</strong></td><td><strong>生产者-消费者模式中使用</strong></td></tr><tr><td align="left"><strong>memory_order_seq_cst &#x2F; memory_order_acq_rel</strong></td><td><strong>跨多个操作维持一致性和顺序</strong></td></tr></tbody></table><h4 id="1-3-基础用法："><a href="#1-3-基础用法：" class="headerlink" title="1.3 基础用法："></a>1.3 <strong>基础用法</strong>：</h4><ul><li><code>store()</code>：存储值</li><li><code>load()</code>：加载值</li><li><code>exchange()</code>：交换值</li><li><code>compare_exchange_strong()</code>：比较交换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 消费者</span><br>std::atomic&lt;<span class="hljs-type">bool</span>&gt;  g_bRunning&#123;<span class="hljs-literal">true</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">workThread</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;        <br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">100</span>);       <br>        <span class="hljs-keyword">if</span> (g_bRunning.<span class="hljs-built_in">load</span>(std::memory_order_acquire))<span class="hljs-keyword">break</span>;<br>        ...<br>    &#125;;<br>&#125;<br><span class="hljs-comment">// 生产者</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>&#123; g_bRunning.<span class="hljs-built_in">store</span>(<span class="hljs-literal">false</span>, std::memory_order_release);&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-注意事项："><a href="#1-4-注意事项：" class="headerlink" title="1.4 注意事项："></a>1.4 <strong>注意事项</strong>：</h4><ul><li>复合操作不是原子操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::atomic&lt;<span class="hljs-type">int</span>&gt; balance&#123;<span class="hljs-number">100</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unsafe_withdraw</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (balance &gt;= amount) &#123;<br>        balance -= amount;  <span class="hljs-comment">// 包括balance&gt;=amount和balance-=amount两个操作，最后一个可能被中断</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-std-mutex-std-lock-guard"><a href="#2-std-mutex-std-lock-guard" class="headerlink" title="2 std::mutex + std::lock_guard"></a>2 <code>std::mutex</code> + <code>std::lock_guard</code></h3><h4 id="2-1-适用场景："><a href="#2-1-适用场景：" class="headerlink" title="2.1 适用场景："></a>2.1 <strong>适用场景</strong>：</h4><p>​需要简单作用域锁保护的临界区，不需要手动管理锁的生命周期。</p><h4 id="2-2-基础用法："><a href="#2-2-基础用法：" class="headerlink" title="2.2 基础用法："></a>2.2 <strong>基础用法</strong>：</h4><ul><li><p><code>std::mutex</code>：互斥锁</p><ul><li><code>lock()</code>：阻塞线程直到获取锁（若锁已被占用，则等待；</li><li><code>unlock()</code>：释放锁（必须<code>lock()</code>成对调用，否则死锁）；</li><li><code>trylock()</code>：尝试非阻塞获取锁，成功返回 <code>true</code>，失败返回 <code>false</code>。</li></ul></li><li><p><code>std::lock_gurad</code>：RAII锁管理器</p><ul><li>构造时上锁，析构时解锁；</li><li>异常安全，即使代码抛出异常，也能保证解锁。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::mutex g_mtx;<br><span class="hljs-type">int</span> g_iShare = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">safe_increment</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::lock_gurad&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(g_mtx)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>        g_iShare++;<br>&#125;<br><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(safe_increment)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(safe_increment)</span></span>;<span class="hljs-comment">// g_iShare为20000</span><br></code></pre></td></tr></table></figure><h4 id="2-3-注意事项："><a href="#2-3-注意事项：" class="headerlink" title="2.3 注意事项："></a>2.3 <strong>注意事项</strong>：</h4><ul><li>避免手动<code>lock()</code>&#x2F;<code>unlock()</code>(出现异常导致没有解锁),尽量使用<code>std::lock_gurad</code>&#x2F;<code>std::unique_lock</code>；</li><li>最小临界区原则；</li><li>小心嵌套锁导致的死锁（需嵌套锁时用 <code>std::recursive_mutex</code>）。</li></ul><h3 id="3-std-condition-variable-std-unique-lock"><a href="#3-std-condition-variable-std-unique-lock" class="headerlink" title="3 std::condition_variable + std::unique_lock"></a>3 <code>std::condition_variable</code> + <code>std::unique_lock</code></h3><h4 id="3-1-适用场景："><a href="#3-1-适用场景：" class="headerlink" title="3.1 适用场景："></a>3.1 <strong>适用场景</strong>：</h4><p>​生产者-消费者模式（队列通信）、等待某个事件、定时唤醒+条件检查。</p><h4 id="3-2-基础用法："><a href="#3-2-基础用法：" class="headerlink" title="3.2 基础用法："></a>3.2 <strong>基础用法</strong>：</h4><ul><li><code>std::condition_variable</code>：条件变量<ul><li><code>notify_one()</code>：唤醒一个正在等待该条件变量的线程（不确定是哪一个）；</li><li><code>notify_all()</code>：唤醒所有正在等待该条件变量的线程；</li><li><code>wait(lock, pred)</code>：带谓语的等待，只有<code>pred</code>函数返回<code>false</code>才进入等待（如果<code>lock</code>持有互斥量，并<code>pred</code>函数返回<code>false</code>，那么<code>wait</code>会自动释放<code>lock</code>，让其他线程获得互斥量）；</li><li><code>wait_for(duration_rel,lock, pred)</code>：带谓语和超时时间的等待</li></ul></li><li><code>std::unique_lock</code>：灵活锁管理<ul><li><code>lock()</code>：尝试获取互斥量的所有权，若互斥量被其他线程占用，就堵塞当前线程等待；</li><li><code>unlock()</code>：释放互斥量的所有权，允许其他线程获的互斥量的所有权；</li><li><code>trylock()</code>：尝试非阻塞获取锁，成功返回 <code>true</code>，失败返回 <code>false</code>。</li><li><code>owns_lock()</code>：检查是否拥有互斥量的所有权。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::queue&lt;<span class="hljs-type">int</span>&gt; g_dataQueue;<br>std::mutexg_mtxData;<br>std::condition_variable g_cvData;<br>std::atomic&lt;<span class="hljs-type">bool</span>&gt;g_bExit&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-comment">// 消费者</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(g_mtxData)</span></span>;<br>        g_cvData.<span class="hljs-built_in">wait</span>(lock, []()&#123;<span class="hljs-keyword">return</span> !g_dataQueue.<span class="hljs-built_in">empty</span>() || g_bExit.<span class="hljs-built_in">load</span>();&#125;);<br>        <span class="hljs-keyword">if</span> (g_bExit.<span class="hljs-built_in">load</span>() &amp;&amp; g_dataQueue.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">break</span>;<br>        <br>        std::cout&lt;&lt;g_dataQueue.<span class="hljs-built_in">front</span>()&lt;&lt;std::endl;<br>        g_dataQueue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>&#125;<br><span class="hljs-comment">// 生产者</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">generate_data</span>();<span class="hljs-comment">// 模拟生产数据函数</span><br>        &#123;<span class="hljs-comment">// 空的&#123;&#125;作用域，缩小临界区范围</span><br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(g_mtxData)</span></span>;<span class="hljs-comment">// 构造时传入互斥量，立马锁住</span><br>            g_dataQueue.<span class="hljs-built_in">push</span>(n);<br>        &#125;<br>        g_cvData.<span class="hljs-built_in">notify_one</span>();<span class="hljs-comment">// 通知某个等待线程</span><br>    &#125;<br>    g_bExit = <span class="hljs-literal">true</span>;<br>    g_cvData.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-comment">// 通知所有线程结束</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-注意事项："><a href="#3-3-注意事项：" class="headerlink" title="3.3 注意事项："></a>3.3 <strong>注意事项</strong>：</h4><ul><li>始终使用带谓语<code>wait()</code>，避免虚假唤醒；</li><li>修改共享资源数据后调用<code>notify_one/notify_all</code>,避免错过通知（不是多个消费者时优先使用<code>notify_one</code>）;</li><li>段时间小范围持有锁，提高并发效率；</li><li>避免在谓语中做复杂&#x2F;耗时操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言与框架</category>
      
      <category>C++</category>
      
      <category>C++11</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11 其他特性</title>
    <link href="/2025/06/18/C++11%2006%20%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7/"/>
    <url>/2025/06/18/C++11%2006%20%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="一、初始化列表："><a href="#一、初始化列表：" class="headerlink" title="一、初始化列表：{ }"></a>一、初始化列表：{ }</h2><p>​为了解决传统初始化方式的不一致问题而诞生，显著提高了安全性和表达能力。</p><h3 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1 相关概念"></a>1 相关概念</h3><ul><li><code>std::initializer_list&lt;T&gt;</code>：初始化列表，接受数量可变，类型相同的一组数据。</li><li><code>&#123;&#125;</code>：初始化列表语言支持的语法糖，可以把它理解为一个<code>std::initializer_list&lt;T&gt;</code>类型的临时对象。</li></ul><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">T obj&#123;arg1, arg2, ...&#125;;<span class="hljs-comment">// 直接初始化</span><br>T obj = &#123;arg1, arg2, ...&#125;;<span class="hljs-comment">// 创建一个std::initializer_list&lt;decltype(arg1)&gt;临时对象，再构造obj</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;提示&#x3D;&#x3D;：代替传统小括号<code>()</code>和赋值号<code>=</code>的初始化方式；以上的<code>arg1</code>、<code>arg2</code>等参数是同一类型。</p><h3 id="3-关键特性"><a href="#3-关键特性" class="headerlink" title="3 关键特性"></a>3 关键特性</h3><ul><li>统一初始化，适用于所有类型；</li><li>禁止窄化转换，阻止可能导致数据丢失的隐式转换；</li><li>自动推导元素数量；</li><li>优先匹配 <code>initializer_list</code> 构造函数；</li></ul><h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4 使用场景"></a>4 使用场景</h3><p>​需要遍历整个容器且没有修改容器结构（<strong>删除&#x2F;插入元素</strong>）需求时使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; v&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">// 1、初始化容器</span><br>std::map&lt;<span class="hljs-type">int</span>, std::string&gt; m&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-string">&quot;one&quot;</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>&#125;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::initialer_list&lt;<span class="hljs-type">int</span>&gt; args)</span></span>;<span class="hljs-comment">// 2、函数参数</span><br><span class="hljs-built_in">func</span>(&#123;<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>&#125;);<br><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">createVector</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;; &#125;<span class="hljs-comment">// 3、函数返回值</span><br></code></pre></td></tr></table></figure><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5 注意事项"></a>5 注意事项</h3><ul><li><code>std::initializer_list</code>是只读视图，其内元素不可修改；</li><li>构造函数重载优先级问题；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">T t1&#123;arg1,arg2,...&#125;;    <span class="hljs-comment">// 优先调用T(std::initializer_list&lt;decltype(arg1)&gt; list);</span><br><span class="hljs-function">T <span class="hljs-title">t2</span><span class="hljs-params">(arg1,arg2,...)</span></span>;<span class="hljs-comment">// 优先调用T(arg1,arg2,...);</span><br>T t3&#123;&#125;<span class="hljs-comment">// 优先调用默认构造函数</span><br></code></pre></td></tr></table></figure><ul><li>与 <code>auto</code> 的交互问题。</li></ul><h2 id="二、范围for循环"><a href="#二、范围for循环" class="headerlink" title="二、范围for循环"></a>二、范围for循环</h2><p>​为了简化容器的遍历而引入，使代码更简洁、安全且易懂。</p><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(元素类型 元素变量: 容器)<br>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;提示&#x3D;&#x3D;：其底层使用传统for循环遍历实现。</p><h3 id="2-支持多种容器类型"><a href="#2-支持多种容器类型" class="headerlink" title="2 支持多种容器类型"></a>2 支持多种容器类型</h3><ul><li>标准<code>STL</code>容器；</li><li>原生数组；</li><li>初始化列表：<code>&#123;&#125;</code>;</li><li>字符串：<code>std::string</code></li><li>已实现<code>begin()/end()</code>的自定义容器。</li></ul><h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3 使用场景"></a>3 使用场景</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: std::vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;)&#123;...&#125;;<span class="hljs-comment">// 常量引用，推荐只读</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [key, val]: myMap)&#123;...&#125;;<span class="hljs-comment">// 引用，可修改元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i: &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;)&#123;...&#125;;<span class="hljs-comment">// 拷贝，复杂类型会影响性能</span><br></code></pre></td></tr></table></figure><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4 注意事项"></a>4 注意事项</h3><ul><li>遍历过程不能执行<strong>删除&#x2F;插入</strong>操作，会导致迭代器失效和未定义行为（如需要修改容器结构，请使用传统<code>for</code>循环）；</li><li>临时容器会延长至循环结束；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;)&#123;...&#125;<br></code></pre></td></tr></table></figure><h2 id="三、强类型枚举：enum-class"><a href="#三、强类型枚举：enum-class" class="headerlink" title="三、强类型枚举：enum class"></a>三、强类型枚举：enum class</h2><h3 id="1-为什么引入？"><a href="#1-为什么引入？" class="headerlink" title="1 为什么引入？"></a>1 为什么引入？</h3><p>为了解决传统enum以下问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// 1 作用域污染问题</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;RED, GREEN, BLUE&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">TrafficLight</span> &#123; RED, YELLOW, GREEN &#125;; <span class="hljs-comment">/// 错误：重定义</span><br><span class="hljs-comment">/// 2 隐私类型转换</span><br>Color c = RED;<br><span class="hljs-type">int</span> i = c;  <span class="hljs-comment">/// 隐私转为为int（通常不期望）</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">1</span>)  <span class="hljs-comment">/// 与整形比较（类型不安全）</span><br><span class="hljs-comment">/// 3 底层实现类型不明确</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Type</span>&#123;A = <span class="hljs-number">0</span>, B, End = <span class="hljs-number">0xffffffff</span>&#125;<span class="hljs-comment">/// 底层实现是int或者unsigned int</span><br><span class="hljs-comment">/// 4 无法向前声明（头文件中）</span><br><span class="hljs-keyword">enum</span> IOType;<span class="hljs-comment">/// c++03 错误，需要完整定义</span><br></code></pre></td></tr></table></figure><h3 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2 基本使用"></a>2 基本使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// 1 定义</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span>&#123;RED, GREEN, BLUE&#125;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">TrafficLight</span> &#123; RED, YELLOW, GREEN &#125;; <br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">IOType</span> : <span class="hljs-type">int</span> &#123; IORead = <span class="hljs-number">1</span>, IOWrite, IOUnknown = <span class="hljs-number">0</span>&#125;<br><br><span class="hljs-comment">/// 2 使用需使用作用域显示指定</span><br>Color c1 = Color::RED, c2 = Color::GREEN;<br>TrafficLight tl = TrafficLight::RED;<br><br><span class="hljs-comment">/// 3 不能类型隐私转换</span><br><span class="hljs-type">int</span> ic = c1;  <span class="hljs-comment">/// 错误</span><br><br><span class="hljs-comment">/// 4 类型安全比较</span><br><span class="hljs-keyword">if</span> (c1 == c2)&#123; ... &#125;<br><span class="hljs-keyword">if</span> (c1 == tl) &#123; ... &#125;  <span class="hljs-comment">/// 错误：类型不比配</span><br><br><span class="hljs-comment">/// 5 显示转换</span><br><span class="hljs-type">int</span> i = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(c1);<br>Color c3 = <span class="hljs-built_in">static_cast</span>&lt;Color&gt;(<span class="hljs-number">1</span>);<span class="hljs-comment">/// 需要确保数值有效</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;提示&#x3D;&#x3D;：除非需要和以前版本兼容，否则优先选择<code>enum class</code>。</p><h2 id="四、编译期常量-：constexpr"><a href="#四、编译期常量-：constexpr" class="headerlink" title="四、编译期常量 ：constexpr"></a>四、编译期常量 ：constexpr</h2><h3 id="1-为什么引入？-1"><a href="#1-为什么引入？-1" class="headerlink" title="1 为什么引入？"></a>1 为什么引入？</h3><p>解决<code>const</code>以下局限性而引入：</p><ul><li><code>const</code>常量表达式运行时期才计算值，而<code>constexpr</code>常量表达式在所有参赛和上下文允许的情况下能够在编译时期就计算值，减少了程序运行时性能开销；</li><li><code>const</code>只能修饰简单常量表达式，而<code>constexpr</code>可用于复杂表达式（如：递归函数）；</li></ul><h3 id="2-基本使用-1"><a href="#2-基本使用-1" class="headerlink" title="2 基本使用"></a>2 基本使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// 1 变量常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> max_size = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535</span>;<br><span class="hljs-type">int</span> arr[max_size];<br><span class="hljs-comment">/// 2 函数常量表达式</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-keyword">return</span> x &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : x * <span class="hljs-built_in">factorial</span>(x<span class="hljs-number">-1</span>); &#125;<br><span class="hljs-type">int</span> n = <span class="hljs-built_in">factorial</span>(<span class="hljs-number">5</span>);<br><span class="hljs-comment">/// 3 类成员变量和函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535</span>;<span class="hljs-comment">/// static修饰确保所有对象共用一个，减少开销</span><br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> (x * x * pi);&#125;<span class="hljs-comment">/// const修饰确保该函数不修改成员变量的值</span><br>&#125;<br>Circle c;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> ca = c.<span class="hljs-built_in">area</span>(<span class="hljs-number">5.0</span>);<span class="hljs-comment">/// 编译时确定，因此返回值需要使用constexpr变量承接 </span><br><span class="hljs-comment">/// 4 和模版一起使用（进阶）</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N&gt;<span class="hljs-comment">/// N为模板非类型参数（一般typename T中的T为类型参数）</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">power_of_two</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt; N; &#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> iReslut = <span class="hljs-built_in">power_of_two</span>&lt;<span class="hljs-number">5</span>&gt;();<span class="hljs-comment">/// 编译时确定</span><br></code></pre></td></tr></table></figure><h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 注意事项</h3><ul><li><code>const</code>和<code>constexpr</code>都能保证值不可修改，但是<code>const</code>是运行时常量<code>constexpr</code>是编译时常量；</li><li><code>constexpr</code>函数自动进行内联，无需手动指定<code>inline</code>;</li><li><code>constexpr</code>递归函数递归深度受到编译器的限制，不同编译器限制不同；</li><li><code>constexpr</code>函数内不能使用内存分（<code>new</code>和<code>malloc</code>），不能使用 <code>std::vector</code>、<code>std::string</code> 等动态类型（其内部使用内存分配）；</li></ul><h2 id="五、别名：using"><a href="#五、别名：using" class="headerlink" title="五、别名：using"></a>五、别名：using</h2><h3 id="1-为什么要引入？"><a href="#1-为什么要引入？" class="headerlink" title="1 为什么要引入？"></a>1 为什么要引入？</h3><ul><li><p><code>typedef</code>无法直接定义模版别名；</p></li><li><p><code>typedef</code>语法在复杂类型（如：函数指针）可读性差。</p></li><li><p>提供对模板元编程的支持（元函数和别名模板）。</p></li></ul><p>&#x3D;&#x3D;核心结论&#x3D;&#x3D;：优先使用<code>using</code>,尤其在模板编程中。</p><h3 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2 基本用法"></a>2 基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// 基本类型</span><br><span class="hljs-keyword">using</span> UInt = <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>;<br><span class="hljs-comment">/// 模板别名</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> vec = std::vector&lt;T&gt;;<br><span class="hljs-comment">/// 函数指针</span><br><span class="hljs-keyword">using</span> funcAdd = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br>funcAdd  add = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123; <span class="hljs-keyword">return</span> a+b;&#125;<span class="hljs-comment">/// 捕获任何变量的lambda表达式才可以转为函数指针</span><br><span class="hljs-comment">/// 成员函数指针（如状态机等）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Handler = <span class="hljs-built_in">void</span> (Widget::*)(<span class="hljs-type">int</span>); <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123; <span class="hljs-comment">/*...*/</span> &#125;<br>&#125;;<br>Widget::Handler handler = &amp;Widget::process;<br>Widget w;<br>(w.*handler)(<span class="hljs-number">42</span>);  <span class="hljs-comment">/// 调用</span><br></code></pre></td></tr></table></figure><h3 id="3-进阶用法"><a href="#3-进阶用法" class="headerlink" title="3 进阶用法"></a>3 进阶用法</h3><ul><li>结合<code>decltype</code>给推导类型取别名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt;  ids;<br><span class="hljs-keyword">using</span> iditer = <span class="hljs-keyword">decltype</span>(ids.<span class="hljs-built_in">begin</span>());<br></code></pre></td></tr></table></figure><ul><li>简化复杂模板类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Cleantype = <span class="hljs-keyword">typename</span> std::remove_cv&lt;<br> <span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;::type;<br>Cleantype&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&gt; i = <span class="hljs-number">10</span>;<span class="hljs-comment">/// i类型为int</span><br><span class="hljs-comment">/// 1 std::remove_reference&lt;T&gt;是个结构体，其内部type成员变量表示去除引用后的类型，同理</span><br><span class="hljs-comment">///std::remove_cv&lt;T&gt;::type是去除const/volatile后的类型；</span><br><span class="hljs-comment">/// 2 由于编译器无法确定::type是不是一个类型，需要使用typename显示告诉编译器；</span><br><span class="hljs-comment">/// 3 从c++14开始，提供了_t后缀版本，可以省略::type和typename,代码更简洁：</span><br><span class="hljs-comment">///std::remove_cv_t&lt;T&gt;等价于typename std::remove_cv&lt;T&gt;::type。</span><br></code></pre></td></tr></table></figure><ul><li>元编程中的类型萃取</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2=<span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-type">enable_if_t</span> = <span class="hljs-keyword">typename</span> std::enable_if&lt;T1,T2&gt;::type;<span class="hljs-comment">/// c++14简洁写法的实现</span><br></code></pre></td></tr></table></figure><h3 id="4-注意事项-1"><a href="#4-注意事项-1" class="headerlink" title="4 注意事项"></a>4 注意事项</h3><ul><li>作用域，遵循常规作用域规则（类内&#x2F;命名空间内&#x2F;局部作用域），在外部可通过加typename访问（类模板中）。</li></ul><h2 id="六、override和final"><a href="#六、override和final" class="headerlink" title="六、override和final"></a>六、override和final</h2><h2 id="七、委托构造函数和继承构造函数"><a href="#七、委托构造函数和继承构造函数" class="headerlink" title="七、委托构造函数和继承构造函数"></a>七、委托构造函数和继承构造函数</h2><h2 id="八、静态断言（static-assert）"><a href="#八、静态断言（static-assert）" class="headerlink" title="八、静态断言（static_assert）"></a>八、静态断言（static_assert）</h2><h2 id="九、可变参数模板"><a href="#九、可变参数模板" class="headerlink" title="九、可变参数模板"></a>九、可变参数模板</h2><h2 id="十、无序关联容器"><a href="#十、无序关联容器" class="headerlink" title="十、无序关联容器"></a>十、无序关联容器</h2>]]></content>
    
    
    <categories>
      
      <category>编程语言与框架</category>
      
      <category>C++</category>
      
      <category>C++11</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11 Lambda匿名函数</title>
    <link href="/2025/06/17/C++11%2001%20Lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <url>/2025/06/17/C++11%2001%20Lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-核心语法"><a href="#一、-核心语法" class="headerlink" title="一、 核心语法"></a>一、 核心语法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">[capture-list](parameters)<span class="hljs-keyword">mutable</span> -&gt; <span class="hljs-keyword">return</span>-type<br>&#123;<br>    <span class="hljs-comment">// func body</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-capture-list：外部变量捕获列表"><a href="#1-capture-list：外部变量捕获列表" class="headerlink" title="1 capture-list：外部变量捕获列表"></a>1 capture-list：外部变量捕获列表</h3><table><thead><tr><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>[]</td><td>不捕获任何变量</td></tr><tr><td>[&#x3D;]</td><td>值捕获所有变量</td></tr><tr><td>[&amp;]</td><td>引用捕获所有变量</td></tr><tr><td>[x]</td><td>值捕获<code>x</code>变量</td></tr><tr><td>[&amp;x]</td><td>引用捕获<code>x</code>变量（在lambda匿名函数内修改<code>x</code>影响外部<code>x</code></td></tr><tr><td>[x,&amp;y]</td><td>值捕获<code>x</code>变量，引用捕获y&#96;变量（混合捕获）</td></tr><tr><td>[&#x3D;,&amp;x]</td><td>除了<code>x</code>变量按值捕获，其他所有变量按引用捕获（混合捕获）</td></tr><tr><td>[&amp;, x]</td><td>除了<code>x</code>变量按引用捕获，其他所有变量按值捕获（混合捕获）</td></tr><tr><td>[this]</td><td>值捕获<code>this</code>指针,<code>this</code>虽然是值捕获，但是和lambda内的副本<code>this</code>指向同一内存，所有还是会影响外部<code>this</code>（对其他指针同理）</td></tr></tbody></table><h3 id="2-parameters：参数列表-可选"><a href="#2-parameters：参数列表-可选" class="headerlink" title="2 parameters：参数列表  [可选]"></a>2 parameters：参数列表  [可选]</h3><p>参数和普通函数一样，从<code>C++14</code>开始支持默认参数。</p><h3 id="3-mutable：可变规范-可选"><a href="#3-mutable：可变规范-可选" class="headerlink" title="3 mutable：可变规范  [可选]"></a>3 mutable：可变规范  [可选]</h3><p>值捕获外部变量默认是<code>const</code>成员变量(lambda底层是函数对象)，如何要修改副本的值，需要添加<code>mutable</code>来消除<code>const</code>属性。</p><h3 id="4-return-type：返回值类型-可选"><a href="#4-return-type：返回值类型-可选" class="headerlink" title="4 return-type：返回值类型  [可选]"></a>4 return-type：返回值类型  [可选]</h3><p>使用<code>-&gt;类型</code>的方式指出返回值类型，如：<code>-&gt;int</code>；当编译器自己能推导出返回值类型时（如：单条<code>return</code>或者<code>void</code>函数）可省略。</p><h3 id="5-…-：函数体"><a href="#5-…-：函数体" class="headerlink" title="5 {…}：函数体"></a>5 {…}：函数体</h3><p>实现函数功能逻辑。</p><h2 id="二、注意事项"><a href="#二、注意事项" class="headerlink" title="二、注意事项"></a>二、注意事项</h2><ul><li><p><strong>引用捕获外部变量或者值捕获外部指针时，注意避免使用<code>悬空指针</code></strong></p></li><li><p><strong>大型对象尽量避免使用值捕获，拷贝开销大</strong></p></li><li><p><strong>不能直接递归，需使用<code>std::function</code>进行封装</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; factorial = [&amp;](<span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-built_in">return</span> (n &lt;= <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : n * <span class="hljs-built_in">factorial</span>(n - <span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>C++14</code>以上参数支持<code>auto</code>声明</li></ul><h2 id="三、经典使用场景"><a href="#三、经典使用场景" class="headerlink" title="三、经典使用场景"></a>三、经典使用场景</h2><ul><li><code>STL</code>算法中的自定义操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123;<span class="hljs-keyword">return</span> a &gt; b;&#125;) <span class="hljs-comment">// 降序</span><br>v.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;),v.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// 过滤偶数</span><br></code></pre></td></tr></table></figure><ul><li>异步任务</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;]() &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;Thread with captured vars\n&quot;</span>;&#125;)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>QT</code>中的槽函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">connect</span>(ui.btnClose, &amp;QPushButton::clicked, [&amp;]() &#123;<span class="hljs-built_in">close</span>(); &#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言与框架</category>
      
      <category>C++</category>
      
      <category>C++11</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11 nullptr/智能指针</title>
    <link href="/2025/06/17/C++11%2002%20C++11%20nullptr%20l%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2025/06/17/C++11%2002%20C++11%20nullptr%20l%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一、nullptr"><a href="#一、nullptr" class="headerlink" title="一、nullptr"></a>一、nullptr</h2><p>传统的<code>NULL</code>被定为为<code>0</code>或者<code>(void*)0</code>,存在二义性，因此引入<code>nullptr</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123;std::cout&lt;&lt;<span class="hljs-string">&quot;int&quot;</span>&lt;&lt;std::endl;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span> </span>&#123;std::cout&lt;&lt;<span class="hljs-string">&quot;int *&quot;</span>&lt;&lt;std::endl;&#125;<br><br><span class="hljs-built_in">func</span>(<span class="hljs-literal">NULL</span>);<span class="hljs-comment">// 可能调用的是func(int), 而非func(int*)</span><br><span class="hljs-built_in">func</span>(nullpter);<span class="hljs-comment">// 明确调用func(int*)</span><br></code></pre></td></tr></table></figure><h2 id="二、std-unique-ptr"><a href="#二、std-unique-ptr" class="headerlink" title="二、std::unique_ptr"></a>二、std::unique_ptr</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1 特点"></a>1 特点</h3><ul><li>独占式，同一时间只有一个<code>unique_ptr</code>指向资源</li><li>不可拷贝（删除拷贝构造函数和赋值运算符），可使用移动语义转移资源的所有权</li></ul><h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2 注意事项"></a>2 注意事项</h3><ul><li>避免使用同一个原始指针初始化多个<code>unique_ptr</code>,会导致原始指针被多次释放；</li><li>不手动释放使用<code>get()</code>获取的原始指针；</li><li>尽量避免在同一对象上混用原始指针和智能指针，这可能导致双重释放或其他未定义行为。</li></ul><h3 id="3-用法"><a href="#3-用法" class="headerlink" title="3 用法"></a>3 用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构造</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<span class="hljs-comment">// 推荐，C++14以上</span><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">100</span>))</span></span>;<br><span class="hljs-comment">// 转移资源所有权</span><br><span class="hljs-keyword">auto</span> ptr2 = std::<span class="hljs-built_in">move</span>(ptr);<br><span class="hljs-comment">// 自定义删除器</span><br><span class="hljs-keyword">auto</span> funcDeleter = [](FILE* f)&#123;<span class="hljs-built_in">fclose</span>(f);&#125;<br><span class="hljs-function">std::unique_ptr&lt;FILE, <span class="hljs-title">decltype</span><span class="hljs-params">(funcDeleter)</span>&gt; <span class="hljs-title">fptr</span><span class="hljs-params">(fopen(<span class="hljs-string">&quot;log.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>), funcDeleter)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-经典使用场景"><a href="#3-经典使用场景" class="headerlink" title="3 经典使用场景"></a>3 经典使用场景</h3><ul><li><strong>资源独占管理</strong>：保证资源在作用域结束后就释放</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> resource = std::<span class="hljs-built_in">make_unique</span>&lt;Resource&gt;();<br>    resource-&gt;<span class="hljs-built_in">doWork</span>();<br>    <span class="hljs-comment">// 自动释放 Resource</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>工厂模式</strong>：返回动态创建的对象，明确所有权转移。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_ptr&lt;Shape&gt; <span class="hljs-title">createShape</span><span class="hljs-params">(ShapeType type)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span>(type) &#123;<br>        <span class="hljs-keyword">case</span> Circle: <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;Circle&gt;();<br>        <span class="hljs-keyword">case</span> Square: <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;Square&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、std-shared-ptr"><a href="#三、std-shared-ptr" class="headerlink" title="三、std::shared_ptr"></a>三、std::shared_ptr</h2><h3 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1 特点"></a>1 特点</h3><ul><li>计数式， 多个<code>shared_ptr</code>同时指向一个资源</li><li>引用计数操作是线程安全，<code>shared_ptr</code>指向的资源不是，需手动同步</li></ul><h3 id="2-注意事项-1"><a href="#2-注意事项-1" class="headerlink" title="2 注意事项"></a>2 注意事项</h3><ul><li>避免多个包含<code>shared_ptr</code>成员的对象互相引用，防止计数不能归零而导致内存泄漏，解决办法使用<code>weak_ptr</code>替换<code>shared_ptr</code>（比如：双向链表）;</li><li>避免使用同一个原始指针初始化多个<code>shared_ptr</code>,会导致原始指针被多次释放。</li><li>尽量避免在同一对象上混用原始指针和智能指针，这可能导致双重释放或其他未定义行为</li></ul><h3 id="3-用法-1"><a href="#3-用法-1" class="headerlink" title="3 用法"></a>3 用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构造</span><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<span class="hljs-comment">// 推荐，C++14以上</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-comment">// 共享所有全，计数+1</span><br><span class="hljs-keyword">auto</span> ptr2 = ptr;<br><span class="hljs-comment">// 自定义删除器</span><br><span class="hljs-function">std::shared_ptr&lt;FILE&gt; <span class="hljs-title">fptr</span><span class="hljs-params">(fopen(<span class="hljs-string">&quot;log.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>), [](FILE* f)&#123;fclose(f);&#125;)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="4-经典使用场景"><a href="#4-经典使用场景" class="headerlink" title="4 经典使用场景"></a>4 经典使用场景</h3><ul><li><p><strong>共享资源</strong>：多线程或者多对象享同一个数据；</p></li><li><p><strong>缓存系统</strong>：缓存对象直到所有用户不存在再释放。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CacheItem</span>&#123;<span class="hljs-comment">//...&#125;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cache</span>&#123;<br>    std::map&lt;std::string, std::shared_ptr&lt;CacheItem&gt;&gt; m_caches;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-std-enable-shared-from-this和shared-from-this-使用"><a href="#5-std-enable-shared-from-this和shared-from-this-使用" class="headerlink" title="5 std::enable_shared_from_this和shared_from_this()使用"></a>5 std::enable_shared_from_this和shared_from_this()使用</h3><h4 id="（1）使用场景和目的"><a href="#（1）使用场景和目的" class="headerlink" title="（1）使用场景和目的"></a>（1）使用场景和目的</h4><table><thead><tr><th>使用场景</th><th>目的</th></tr></thead><tbody><tr><td>异步回调（如网络库、线程池）</td><td>确保对象在回调执行期间不被销毁</td></tr><tr><td>定时器、事件循环</td><td>确保对象在回调执行期间不被销毁</td></tr><tr><td>对象间互相持有 shared_ptr（打破循环引用）</td><td>A 持有 B 的 weak_ptr，B 调用 shared_from_this() 提供给 A</td></tr><tr><td>注册监听器&#x2F;观察者模式</td><td>确保监听器在通知时仍然有效</td></tr></tbody></table><h4 id="（2）举例说明"><a href="#（2）举例说明" class="headerlink" title="（2）举例说明"></a>（2）举例说明</h4><p>假如我们有个<code>MyClass</code>类，其中<code>doAsyncWork（）</code>函数会异步执行耗时工作,如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAsyncWork</span><span class="hljs-params">()</span> </span>&#123; std::<span class="hljs-built_in">thread</span>([<span class="hljs-keyword">this</span>]()&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">doSomething</span>();&#125;).<span class="hljs-built_in">detach</span>(); &#125;    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 耗时工作 */</span>  &#125;<br>&#125;<br><br><span class="hljs-keyword">auto</span> obj = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>obj-&gt;<span class="hljs-built_in">doAsyncWork</span>(); <br></code></pre></td></tr></table></figure><ul><li><p><strong>问题</strong>：如果<code>doAsyncWork()</code>还没执行完，外部所有的<code>std::make_shared&lt;MyClass&gt;</code>提前离开作用域，导致<code>MyClass</code>被释放，此时<code>doAsyncWork()</code>内部的<code>this</code>指针将变成悬空指针。</p></li><li><p><strong>解决思路</strong>：<code>doAsyncWork()</code>函数内持有一个<code>std::shared_ptr&lt;MyClass&gt;</code>延长<code>doAsyncWork()</code>函数内<code>this</code>的生命周期</p><ul><li>错误方法：在<code>doAsyncWork()</code>函数内直接<code>std::shared_ptr&lt;MyClass&gt; self(this)</code>,这样会使<code>self</code>和<code>obj</code>各自维护自己的引用计数，导致多次析构。</li><li>正确方法：让<code>MyClass</code>继承自<code>std::enable_shared_from_this</code>并在<code>doAsyncWork()</code>函数内调用<code>shared_from_this()</code>函数获取一个<code>std::shared_ptr&lt;MyClass&gt;</code>实列。</li></ul></li></ul><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：避免在构造函数内使用<code>shared_from_this()</code>,因为此时对象尚未完全构造完毕，可能会导致未定义行为</p><h2 id="四、std-weak-ptr"><a href="#四、std-weak-ptr" class="headerlink" title="四、std::weak_ptr"></a>四、std::weak_ptr</h2><h3 id="1-特点-2"><a href="#1-特点-2" class="headerlink" title="1 特点"></a>1 特点</h3><ul><li>仅观察资源，不增加引用计数，不管理资源生命周期；</li><li><code>std::weak_ptr</code>主要用于解决<code>std::shared_ptr</code>的循环引用问题，因此必须结合<code>std::shared_ptr</code>一起使用。</li></ul><h3 id="2-注意事项-2"><a href="#2-注意事项-2" class="headerlink" title="2 注意事项"></a>2 注意事项</h3><ul><li>不能直接使用<code>std::weak_ptr</code>访问资源，需先用<code>lock()</code>函数转为<code>std::shared_ptr</code>先;</li><li>因为<code>std::weak_ptr</code>不参与资源生命周期的管理，使用前需转为<code>std::shared_ptr</code>并检查其有效性。</li></ul><h3 id="3-用法-2"><a href="#3-用法-2" class="headerlink" title="3 用法"></a>3 用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构造</span><br><span class="hljs-keyword">auto</span> sptr = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; wptr = sptr;<br><span class="hljs-comment">// 使用前转换为std::shared_ptr并检查其有效性</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ptr = wptr.<span class="hljs-built_in">lock</span>())&#123; <span class="hljs-comment">/* 使用ptr，其类型为std::shared_ptr */</span> &#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 资源已经释放 */</span> &#125;  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言与框架</category>
      
      <category>C++</category>
      
      <category>C++11</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11 右值引用/移动语义/完美转发</title>
    <link href="/2025/06/17/C++11%2003%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%20l%20%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%20l%20%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    <url>/2025/06/17/C++11%2003%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%20l%20%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%20l%20%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="一、右值引用"><a href="#一、右值引用" class="headerlink" title="一、右值引用"></a>一、右值引用</h2><h3 id="1-什么是右值？"><a href="#1-什么是右值？" class="headerlink" title="1 什么是右值？"></a>1 什么是右值？</h3><ul><li><strong>左值（Lvalue）</strong>：具有持久状态的对象，可以取地址，通常有名称。</li><li><strong>右值（Rvalue）</strong>：临时对象或字面量，无法取地址，生命周期短暂。<ul><li><strong>纯右值（prvalue）</strong>：字面量、算术表达式结果、返回非引用的函数调用。</li><li><strong>将亡值（xvalue）</strong>：通过右值引用标记的对象（如 <code>std::move</code> 的结果）</li></ul></li></ul><p>&#x3D;&#x3D;注意：左右值引用声明时一定要初始化&#x3D;&#x3D;</p><h3 id="2-如何判断一个表达式是左值还是右值-？"><a href="#2-如何判断一个表达式是左值还是右值-？" class="headerlink" title="2 如何判断一个表达式是左值还是右值 ？"></a>2 如何判断一个表达式是左值还是右值 ？</h3><ul><li>可位于赋值号（&#x3D;）左边就是左值（左值也可以位于赋值号右边），<code>只能</code>位于赋值号右边的一定是右值</li><li>有名称、可寻址的即为左值，反之为右值</li></ul><p>&#x3D;&#x3D;注意：以上两个方法只使用于大部分情况&#x3D;&#x3D;</p><h3 id="3-右值引用在编程中，一般在什么地方使用？"><a href="#3-右值引用在编程中，一般在什么地方使用？" class="headerlink" title="3 右值引用在编程中，一般在什么地方使用？"></a>3 右值引用在编程中，一般在什么地方使用？</h3><ul><li>函数参数：最常见，一般用于实现移动语义和完美转发；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1.</span> <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other);\\ 移动构造函数<br><span class="hljs-number">2.</span> MyClass&amp; <span class="hljs-keyword">operator</span>=(MyClass&amp;&amp; other);\\ 移动赋值运算符<br><span class="hljs-number">3.</span> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                     \\ 泛型编程中的通用引用，比如实现完美转发时<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br></code></pre></td></tr></table></figure><ul><li>函数返回值：少见，可能会造成悬空引用问题，以前我一直认为右值引用是用来转移资源的，其实不是，它和左值引用一样都是需要引用具体的数据，它只是一个标记，告诉编译器它是右值，让编译器尝试调用移动构造函数或者移动赋值运算符（如何存在的话，这才是资源得以转移的原因），因此，函数返回值没必要设计为右值引用，设计为正常类型就行，如果符合移动语义，编译器自然会自动调用移动构造函数或者移动赋值函数（编译器的RVO或NRVO行为），将资源转移到函数返回时创建的临时变量中，从这里也不能看出，函数返回值默认就是右值，但它的类型不是T&amp;&amp;，而是T。</li></ul><h3 id="4-引用限定符"><a href="#4-引用限定符" class="headerlink" title="4 引用限定符"></a>4 引用限定符</h3><ul><li>无<code>const</code>修饰的成员函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">MyClass<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> &amp; </span>&#123;&#125;    <span class="hljs-comment">// 限定只能左值对象可以调用该函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display1</span><span class="hljs-params">()</span> &amp;&amp; </span>&#123;&#125;  <span class="hljs-comment">// 限定只能右值对象可以调用该函数</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有<code>const</code>修饰的成员函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">MyClass<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp; </span>&#123;&#125;    <span class="hljs-comment">// 左右值对象都可以调用该函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;&amp; </span>&#123;&#125;  <span class="hljs-comment">// 限定只能右值对象可以调用该函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-右值引用最大的用武之地"><a href="#5-右值引用最大的用武之地" class="headerlink" title="5 右值引用最大的用武之地"></a>5 右值引用最大的用武之地</h3><ul><li>移动语义</li><li>完美转发</li></ul><h2 id="二、移动语义"><a href="#二、移动语义" class="headerlink" title="二、移动语义"></a>二、移动语义</h2><h3 id="1-什么是移动语义？"><a href="#1-什么是移动语义？" class="headerlink" title="1 什么是移动语义？"></a>1 什么是移动语义？</h3><p>​移动语义指的就是以<code>移动而非深拷贝</code>的方式初始化含有指针、文件句柄等资源的类对象，通常是将临时对象（右值）资源移动为己用，减少拷贝开销，提升性能。</p><h3 id="2-移动语义的实现"><a href="#2-移动语义的实现" class="headerlink" title="2 移动语义的实现"></a>2 移动语义的实现</h3><p><code>移动构造函数</code>和<code>移动赋值运算符</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other)&#123; &#125;；<br>MyClass&amp; <span class="hljs-keyword">operator</span>=(MyClass&amp;&amp; other) &#123;<br>    <span class="hljs-keyword">if</span> (&amp;other != <span class="hljs-keyword">this</span>)&#123; &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-std-move"><a href="#3-std-move" class="headerlink" title="3 std::move"></a>3 std::move</h3><p>​<code>std::move</code>不是移动资源的作用，它的功能是将一个左值转为右值，<code>触发移动语义</code>。</p><h3 id="4-移动语义使用场景"><a href="#4-移动语义使用场景" class="headerlink" title="4 移动语义使用场景"></a>4 移动语义使用场景</h3><ul><li>资源管理类</li><li>大型对象和不可拷贝对象（<code>std::unique_str</code>、<code>std::mutex</code>）</li></ul><h2 id="三、完美转发"><a href="#三、完美转发" class="headerlink" title="三、完美转发"></a>三、完美转发</h2><h3 id="1-什么是完美转发？"><a href="#1-什么是完美转发？" class="headerlink" title="1 什么是完美转发？"></a>1 什么是完美转发？</h3><p>​在泛型编程中，将函数的参数以<strong>原始的值类别</strong>（左值或右值）转发给其他函数，确保目标函数能正确选择重载版本（如拷贝或移动语义）。</p><h3 id="2-完美转发实现关键点"><a href="#2-完美转发实现关键点" class="headerlink" title="2 完美转发实现关键点"></a>2 完美转发实现关键点</h3><ul><li>将通用引用（右值）作为模板函数的参数类型</li><li>使用<code>std::forward</code>传递参数，保持参数的左右值属性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">CallFunc</span><span class="hljs-params">(T&amp;&amp; v)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">targetFunc</span>(std::forward&lt;T&gt;(v)); &#125;<br></code></pre></td></tr></table></figure><h3 id="3-移动语义使用场景"><a href="#3-移动语义使用场景" class="headerlink" title="3 移动语义使用场景"></a>3 移动语义使用场景</h3><ul><li>包装器函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallFunc</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>&#123;<span class="hljs-built_in">targetFunc</span>(std::forward&lt;Args&gt;(args)...);&#125;<br></code></pre></td></tr></table></figure><ul><li>工厂函数和对象创建</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>...Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">createObject</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>(std::forward&lt;Arsg&gt;(args)...);&#125;<br></code></pre></td></tr></table></figure><ul><li>中间层函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span>...Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">logAndCall</span><span class="hljs-params">(Func&amp;&amp; func, Args&amp;&amp;...)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::forward&lt;Func&gt;(func)(std::forward&lt;Args&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言与框架</category>
      
      <category>C++</category>
      
      <category>C++11</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
